/* EventParserHandler.c generated by valac 0.28.1, the Vala compiler
 * generated from EventParserHandler.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_EVENT_PARSER_HANDLER (event_parser_handler_get_type ())
#define EVENT_PARSER_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EVENT_PARSER_HANDLER, EventParserHandler))
#define EVENT_PARSER_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EVENT_PARSER_HANDLER, EventParserHandlerClass))
#define IS_EVENT_PARSER_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EVENT_PARSER_HANDLER))
#define IS_EVENT_PARSER_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EVENT_PARSER_HANDLER))
#define EVENT_PARSER_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EVENT_PARSER_HANDLER, EventParserHandlerClass))

typedef struct _EventParserHandler EventParserHandler;
typedef struct _EventParserHandlerClass EventParserHandlerClass;
typedef struct _EventParserHandlerPrivate EventParserHandlerPrivate;

#define TYPE_EVENT_PARSER (event_parser_get_type ())
#define EVENT_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EVENT_PARSER, EventParser))
#define IS_EVENT_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EVENT_PARSER))
#define EVENT_PARSER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_EVENT_PARSER, EventParserIface))

typedef struct _EventParser EventParser;
typedef struct _EventParserIface EventParserIface;

#define TYPE_PARSED_EVENT (parsed_event_get_type ())
#define PARSED_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSED_EVENT, ParsedEvent))
#define PARSED_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSED_EVENT, ParsedEventClass))
#define IS_PARSED_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSED_EVENT))
#define IS_PARSED_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSED_EVENT))
#define PARSED_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSED_EVENT, ParsedEventClass))

typedef struct _ParsedEvent ParsedEvent;
typedef struct _ParsedEventClass ParsedEventClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_PARSER_EN (parser_en_get_type ())
#define PARSER_EN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSER_EN, ParserEn))
#define PARSER_EN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSER_EN, ParserEnClass))
#define IS_PARSER_EN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSER_EN))
#define IS_PARSER_EN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSER_EN))
#define PARSER_EN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSER_EN, ParserEnClass))

typedef struct _ParserEn ParserEn;
typedef struct _ParserEnClass ParserEnClass;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

#define TYPE_PARSER_DE (parser_de_get_type ())
#define PARSER_DE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSER_DE, ParserDe))
#define PARSER_DE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSER_DE, ParserDeClass))
#define IS_PARSER_DE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSER_DE))
#define IS_PARSER_DE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSER_DE))
#define PARSER_DE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSER_DE, ParserDeClass))

typedef struct _ParserDe ParserDe;
typedef struct _ParserDeClass ParserDeClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _EventParserHandler {
	GObject parent_instance;
	EventParserHandlerPrivate * priv;
};

struct _EventParserHandlerClass {
	GObjectClass parent_class;
};

struct _EventParserIface {
	GTypeInterface parent_iface;
	ParsedEvent* (*parse_source) (EventParser* self, const gchar* source);
	gchar* (*get_language) (EventParser* self);
};

struct _EventParserHandlerPrivate {
	GeeHashMap* handlers;
};


static gpointer event_parser_handler_parent_class = NULL;

GType event_parser_handler_get_type (void) G_GNUC_CONST;
GType parsed_event_get_type (void) G_GNUC_CONST;
GType event_parser_get_type (void) G_GNUC_CONST;
#define EVENT_PARSER_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_EVENT_PARSER_HANDLER, EventParserHandlerPrivate))
enum  {
	EVENT_PARSER_HANDLER_DUMMY_PROPERTY
};
#define EVENT_PARSER_HANDLER_FALLBACK_LANG "en"
EventParserHandler* event_parser_handler_new (const gchar* lang);
EventParserHandler* event_parser_handler_construct (GType object_type, const gchar* lang);
const gchar* event_parser_handler_get_locale (EventParserHandler* self);
void event_parser_handler_register_handler (EventParserHandler* self, const gchar* lang, EventParser* parser);
ParserEn* parser_en_new (GDateTime* _simulated_dt);
ParserEn* parser_en_construct (GType object_type, GDateTime* _simulated_dt);
GType parser_en_get_type (void) G_GNUC_CONST;
GType parser_de_get_type (void) G_GNUC_CONST;
ParserDe* parser_de_new (GDateTime* _simulated_dt);
ParserDe* parser_de_construct (GType object_type, GDateTime* _simulated_dt);
gchar* event_parser_get_language (EventParser* self);
EventParser* event_parser_handler_get_parser (EventParserHandler* self, const gchar* lang);
static void event_parser_handler_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


EventParserHandler* event_parser_handler_construct (GType object_type, const gchar* lang) {
	EventParserHandler * self = NULL;
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GDateTime* _tmp3_ = NULL;
	GDateTime* _tmp4_ = NULL;
	ParserEn* _tmp5_ = NULL;
	ParserEn* _tmp6_ = NULL;
	ParserDe* parser = NULL;
	GDateTime* _tmp7_ = NULL;
	GDateTime* _tmp8_ = NULL;
	ParserDe* _tmp9_ = NULL;
	ParserDe* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	self = (EventParserHandler*) g_object_new (object_type, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_EVENT_PARSER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->handlers);
	self->priv->handlers = _tmp0_;
	_tmp1_ = lang;
	if (_tmp1_ == NULL) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = event_parser_handler_get_locale (self);
		lang = _tmp2_;
	}
	_tmp3_ = g_date_time_new_now_local ();
	_tmp4_ = _tmp3_;
	_tmp5_ = parser_en_new (_tmp4_);
	_tmp6_ = _tmp5_;
	event_parser_handler_register_handler (self, EVENT_PARSER_HANDLER_FALLBACK_LANG, (EventParser*) _tmp6_);
	_g_object_unref0 (_tmp6_);
	_g_date_time_unref0 (_tmp4_);
	_tmp7_ = g_date_time_new_now_local ();
	_tmp8_ = _tmp7_;
	_tmp9_ = parser_de_new (_tmp8_);
	_tmp10_ = _tmp9_;
	_g_date_time_unref0 (_tmp8_);
	parser = _tmp10_;
	_tmp11_ = event_parser_get_language ((EventParser*) parser);
	_tmp12_ = _tmp11_;
	event_parser_handler_register_handler (self, _tmp12_, (EventParser*) parser);
	_g_free0 (_tmp12_);
	_g_object_unref0 (parser);
	return self;
}


EventParserHandler* event_parser_handler_new (const gchar* lang) {
	return event_parser_handler_construct (TYPE_EVENT_PARSER_HANDLER, lang);
}


void event_parser_handler_register_handler (EventParserHandler* self, const gchar* lang, EventParser* parser) {
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	EventParser* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (lang != NULL);
	g_return_if_fail (parser != NULL);
	_tmp0_ = self->priv->handlers;
	_tmp1_ = lang;
	_tmp2_ = parser;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp0_, _tmp1_, _tmp2_);
}


EventParser* event_parser_handler_get_parser (EventParserHandler* self, const gchar* lang) {
	EventParser* result = NULL;
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GeeHashMap* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gpointer _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (lang != NULL, NULL);
	_tmp0_ = self->priv->handlers;
	_tmp1_ = lang;
	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp1_);
	if (!_tmp2_) {
		GeeHashMap* _tmp3_ = NULL;
		gpointer _tmp4_ = NULL;
		_tmp3_ = self->priv->handlers;
		_tmp4_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, EVENT_PARSER_HANDLER_FALLBACK_LANG);
		result = (EventParser*) _tmp4_;
		return result;
	}
	_tmp5_ = self->priv->handlers;
	_tmp6_ = lang;
	_tmp7_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, _tmp6_);
	result = (EventParser*) _tmp7_;
	return result;
}


const gchar* event_parser_handler_get_locale (EventParserHandler* self) {
	const gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_getenv ("LANGUAGE");
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ":", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = _tmp3_[0];
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp5_;
	return result;
}


static void event_parser_handler_class_init (EventParserHandlerClass * klass) {
	event_parser_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (EventParserHandlerPrivate));
	G_OBJECT_CLASS (klass)->finalize = event_parser_handler_finalize;
}


static void event_parser_handler_instance_init (EventParserHandler * self) {
	self->priv = EVENT_PARSER_HANDLER_GET_PRIVATE (self);
}


static void event_parser_handler_finalize (GObject* obj) {
	EventParserHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_EVENT_PARSER_HANDLER, EventParserHandler);
	_g_object_unref0 (self->priv->handlers);
	G_OBJECT_CLASS (event_parser_handler_parent_class)->finalize (obj);
}


/***
  BEGIN LICENSE

  Copyright (C) 2015 Mario Guerriero <marioguerriero33@gmail.com>
  This program is free software: you can redistribute it and/or modify it
  under the terms of the GNU Lesser General Public License version 3, as published
  by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranties of
  MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
  PURPOSE.  See the GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program.  If not, see <http://www.gnu.org/licenses/>

  END LICENSE
***/
GType event_parser_handler_get_type (void) {
	static volatile gsize event_parser_handler_type_id__volatile = 0;
	if (g_once_init_enter (&event_parser_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EventParserHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) event_parser_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EventParserHandler), 0, (GInstanceInitFunc) event_parser_handler_instance_init, NULL };
		GType event_parser_handler_type_id;
		event_parser_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "EventParserHandler", &g_define_type_info, 0);
		g_once_init_leave (&event_parser_handler_type_id__volatile, event_parser_handler_type_id);
	}
	return event_parser_handler_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



